import ast
import textwrap
from datetime import datetime
from pathlib import Path

from navrim.util import get_project_path

type_mapping = {
    "str": "string",
    "int": "number",
    "float": "number",
    "bool": "boolean",
    None: "null",
}


def is_pydantic_model(node: ast.ClassDef) -> bool:
    return any(isinstance(base, ast.Name) and base.id == "BaseModel" for base in node.bases)


def parse_annotation(annotation: ast.expr) -> str:
    if isinstance(annotation, ast.Name):
        return type_mapping[annotation.id]
    if isinstance(annotation, ast.Constant):
        return type_mapping[annotation.value]
    elif isinstance(annotation, ast.BinOp):
        # Handle union types (e.g., str | None)
        if isinstance(annotation.op, ast.BitOr):
            left_type = parse_annotation(annotation.left)
            right_type = parse_annotation(annotation.right)
            return f"{left_type} | {right_type}"
        else:
            raise ValueError(f"Unsupported binary operation at line {annotation.lineno}: {annotation.op}")
    else:
        raise ValueError(f"Unsupported annotation at line {annotation.lineno}: {annotation}")


def pydantic_to_typescript(source_path: Path, target_path: Path, indent: int = 2):
    python_code = source_path.read_text()
    tree = ast.parse(textwrap.dedent(python_code).strip())
    ts_interfaces = []
    for node in ast.walk(tree):
        if not isinstance(node, ast.ClassDef) or not is_pydantic_model(node):
            continue
        interface_name = node.name
        type_mapping.setdefault(interface_name, interface_name)
        ts_fields = []
        for item in node.body:
            if isinstance(item, ast.AnnAssign):
                field_name = item.target.id
                ts_type = parse_annotation(item.annotation)
                ts_fields.append(f"{' ' * indent}{field_name}: {ts_type};")
        fields_str = "\n".join(ts_fields)
        if fields_str:  # interface is not empty
            interface_code = f"export interface {interface_name} {{\n{fields_str}\n}};\n"
        else:
            interface_code = f"export type {interface_name} = Record<string, never>;\n"
        ts_interfaces.append(interface_code)
    header = (
        f"// This file is generated by {Path(__file__).relative_to(get_project_path())} "
        f"at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        "// DO NOT MODIFY THIS FILE DIRECTLY OR YOUR CHANGES WILL BE OVERWRITTEN BY THE NEXT GENERATION.\n"
    )
    typescript_code = "\n".join([header] + ts_interfaces)
    target_path.write_text(typescript_code)
    type_mapping.setdefault(interface_name, interface_name)


if __name__ == "__main__":
    pydantic_to_typescript(
        get_project_path().parent / "navrim" / "navrim" / "protocol" / "request.py",
        get_project_path().parent / "dashboard" / "src" / "protocol" / "request.ts",
    )
    pydantic_to_typescript(
        get_project_path().parent / "navrim" / "navrim" / "protocol" / "response.py",
        get_project_path().parent / "dashboard" / "src" / "protocol" / "response.ts",
    )
